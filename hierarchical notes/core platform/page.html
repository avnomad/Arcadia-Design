<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Core Platform</title>
</head><body><ul><li><b>Parsing</b></li>
<li style="list-style-type: none"><ul><li>Support defining and overloading operators.</li>
<li>You should be able to specify the <b>fixity, arity, precedence</b>&nbsp;(or priority, or scope) and <b>associativity </b>of each operator and overload them.</li>
<li>Support for distfix operators.</li>
<li>Support juxtaposition.</li>
<li style="list-style-type: none"><ul><li>Juxtaposition will be considered a binary operator and will obey the same rules as other binary operators when it comes to importing it into a scope.</li>
<li><b>Use cases</b>:</li>
<li style="list-style-type: none"><ul><li>multiplication</li>
<li>string concatenation</li>
<li>stream insertion / extraction</li>
</ul>
</li>
</ul>
</li>
<li>Classification of tokens into <b>initiators</b>, <b>separators</b>, <b>terminators</b>&nbsp;and <b>operands</b>.</li>
<li>Operator associativity could be relevant for unary operators too, if you consider them as potential values. e.g. a!! ≔ (a!)! or a(!!) ?</li>
<li>Support associativity option that makes <tt>(a&lt;b)&lt;c ≠ a&lt;b&lt;c ≠ a&lt;(b&lt;c)</tt>&nbsp;and allows defining <tt>a&lt;b&lt;c</tt>&nbsp;as a<tt>&lt;b and b&lt;c</tt>&nbsp;(similarly for ⟶ (implies) and =)</li>
<li>Support mixing operators with the above associativity option. e.g. <tt>a&lt;b=c&gt;b</tt>.</li>
<li>No special syntax is needed to treat an operator as a function since placeholder arguments can do the job. e.g. <tt>$0 ? $1 : $2</tt></li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Allow more than one associativity per priority?</li>
<li>I could decouple the insertion of names in a scope from the operator status of them. e.g. I could have a function named '+' with 'prefix' syntax, that would only be parsed as a prefix operator if the prefix + has been activated in the scope. Otherwise it would be parsed as a regular function.</li>
<li>Overloading the membership operator '.' like I've thought, should be similar but more powerful than D's opDispatch.</li>
<li>Constructors, destructors, deconstructors, methods, function, etc. can be thought of as being in different namespaces instead of being different ways to phrase a function call. So e.g. in the first part of a declaration, names will be looked up in the deconstructor namespace, while in the initializer part of a declaration, they will be looked up in the function namespace. Moreover, this way there can be multiple versions of some operators (e.g. [ , , , ]) without fear of collision.</li>
<li style="list-style-type: none"><ul><li>The same technique can be used to separate operators that accept and return values (used in eager contexts like e.g. compile-time commands) and their duals that accept and return syntax trees (used in lazy contexts like e.g. function bodies).</li>
</ul>
</li>
<li><b>Implementation</b></li>
<li style="list-style-type: none"><ul><li>Maybe I can use the 0x2062 INVISIBLE TIMES Unicode character to simplify implementation of juxtaposition parsing.</li>
<li>Every keyword, operator, separator as well as identifiers could have a unique numerical id that would lead to a separate handling function via an array, or could be represented as an object of a different class and the right function would be selected using dynamic dispatch. That's from before I made my first parser...</li>
</ul>
</li>
</ul>
</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Should I assign meaning to expressions where one or more operator arguments are missing or should they be syntax errors? And if I assign meaning what would it be? Can the parser support it?</li>
<li style="list-style-type: none"><ul><li><b>Examples</b>:</li>
<li style="list-style-type: none"><ul><li>(+) could refer to operator '+' as a function (But would that function be the infix or the prefix '+'? Perhaps the context would expect a unary function resolving the ambiguity.)</li>
<li>[&gt;=2] could be equivalent to [$0 &gt;= 2].</li>
</ul>
</li>
<li><b>Use Cases</b>:</li>
<li style="list-style-type: none"><ul><li>Obviate the need for a special operator like <b>op</b>&nbsp;or <b>operator</b>&nbsp;(or something similar) for passing operators as function arguments to other functions.</li>
</ul>
</li>
</ul>
</li>
<li>Make sure <tt>(flag ? x : y) += 5;</tt>&nbsp;is properly supported.</li>
<li>If I make the membership operator ('.') user-defined, how will I avoid confusion between a field and a variable with the same name? e.g. <tt>y</tt>&nbsp;in <tt>p.y</tt>&nbsp;with a variable <tt>y</tt>.</li>
<li style="list-style-type: none">One idea is to take the right hand side argument as an AST, use the name of the argument ("y") and ignore its type and address. That might allow a syntax like OpenCL's .yzxw as well.</li>
<li style="list-style-type: none">Another idea is to enable operators to define names inside their 'scope'. So e.g. '$' will only be defined inside the brackets in <tt>a[$-1]</tt>&nbsp;and 'yzxw' will only be defined after the '.' in <tt>v.yzxw</tt>.</li>
<li>Confirm my parser supported operators that have simultaneous prefix, infix and postfix status and could parse the expressions that weren't ambiguous. It certainly handled cases where 2 out of the 3 fixities were active at any time.</li>
<li>Investigate connection with Categorial Grammars. Would forward and backward functional composition reductions be useful in my case? Some classes of categorial grammars have the same expressive power as context-free grammars.</li>
</ul>
</li>
</ul>
</li>
<li><b>Compilation</b></li>
<li style="list-style-type: none"><ul><li><b>Partial Evaluation</b></li>
<li style="list-style-type: none"><ul><li>compile-time evaluation ⊂ partial evaluation ⊂ supercompilation. I'll probably need the latter!</li>
<li>It may be too expensive to interpret the functions during compile time. They might need to be compiled first. JIT compiler for the compilation, compiler for producing the executable!</li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Attach compiler to executable to allow partial evaluation even during run-time?</li>
</ul>
</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Define for the compile-time environment characteristics similar to the ones for the run-time environment. e.g. what do the following mean?</li>
<li style="list-style-type: none"><ul><li>Assignment to a global variable. Some options are the following:</li>
<li style="list-style-type: none"><ul><li>Prohibit calls to functions that refer to global variables during compilation. (I'll probably not use that)</li>
<li>Allocate space for the global variables in the compiler process as well.</li>
<li style="list-style-type: none"><ul><li>Initialize the variables once for the compiler process and once again for the resulting executable program.</li>
<li>Let the global variables of the resulting executable be initialized with the last value they had during compilation.</li>
<li style="list-style-type: none"><ul><li>The latter idea taken to the extreme can result in a form of "gradual partial evaluation" of the program: The compiler process is gradually transformed to the output program process, with things that are no longer useful (e.g. the parser) being garbage-collected periodically. The result of any of the intermediate steps of this continuous transformation can be saved to file as an executable. In a sense, compilation (and specialization) never ends.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Call to an output function</li>
</ul>
</li>
<li>Clarify semantics around side-effects in the context of partial evaluation / instantiation.</li>
<li>Clarify semantics around compile-time evaluation of floating-point expressions during cross-compilation, when target and host architecture floating-point models, don't match.</li>
<li style="list-style-type: none"><ul><li>The problem disappears if floating-point types are libraries and each library defines its own semantics that will be the same for compile- and run-time. Each floating-point model can have its own library and be implemented using the corresponding machine instructions when the platform supports it or software when it doesn't.</li>
</ul>
</li>
<li>Clarify the semantics and representation of types in the compile- and run-time environments. e.g. int in the compile-time environment will be closer to C's int, while in the run-time environment will be closer to Java's int.class.</li>
</ul>
</li>
</ul>
</li>
<li><b>Output files</b></li>
<li style="list-style-type: none"><ul><li>Compile header/interface files to binary headers and source files to object files respectively and archive them both in a single file.</li>
<li>Source files could be compiled directly to a module file that contains both the object and module header files. A utility could extract the two files from the module and build a module from the comprising files whenever this is needed. e.g. When the source code is not available, but the object file is and the header has to be written explicitly. The latter can happen when you have to link with operating system routines.</li>
</ul>
</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>How will a function gain access to the name of the function that called it and the line number, file name, etc. of the call site so that it can print an error message?</li>
</ul>
</li>
</ul>
</li>
<li><b>Run-time Environment</b></li>
<li style="list-style-type: none"><ul><li>If a function has escaping closures, its stack frame will be allocated on the heap instead (like in D).</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Select one of the methods to implement static scoping in deeply nested functions (<b>access links</b>&nbsp;or <b>link tables</b>).</li>
<li>How exactly will an escaping closure be handled in a deeply nested function setting?</li>
</ul>
</li>
</ul>
</li>
<li><b>Intrinsics</b></li>
<li style="list-style-type: none"><ul><li>HLT function?</li>
<li>Together with primitive operations for integer addition, subtraction, etc. counting of set bits of a number, and other usual machine instructions. It would be good to have machine vector operations and maybe some primitives for copying memory blocks and converting strings to numbers.</li>
<li>Two intrinsics that the language could provide to the programmers for implementing return by external reference (each by itself) are the following (names can be changed):</li>
<li style="list-style-type: none"><ul><li><b>obviate(l-value, ext&amp;)</b>: The l-value must be used as the hidden parameter instead of allocating a new object.</li>
<li><b>swap_symbols(a,b)</b>: Swap the two symbols in the symbol table so that all future references to a refer to b and vice versa. This might cause confusion, especially if someone has kept the address of one of the variables that participated in the swap.</li>
</ul>
</li>
</ul>
</li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>If I need to reserve space for objects at link-time, the ELF 'common' objects can help!</li>
<li>Define some sort of "Hardware Abstraction Language" that will be a little higher-level than an intermediate language and will replace build-in types.</li>
<li>Could define the code each operation generates in assembly, then ship those definitions with the compiler.</li>
</ul>
</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Clarify the semantics for "booting" or "bootstrapping" into the initial language. Probably have the internal data structures be initialized by a hard-coded default.</li>
<li>If the compiler hands off the integer literals to the "substrate" as strings so that they can be converted to numbers, then how will the substrate functions that do the conversion be written?</li>
<li style="list-style-type: none">Perhaps it can be done with the use of symbols like <tt>int.zero</tt>&nbsp;and <tt>int.one</tt>.</li>
<li>What do I need in order for the compiler to know that n &lt; 0 is always false for n ∈ ℕ. And that while(n &lt; 0) is an infinite loop?</li>
</ul>
</li>
</ul>
</body></html>