<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Functions</title>
</head><body><ul><li><b>Function call</b></li>
<li style="list-style-type: none"><ul><li>When you bind one or more function parameters to specific arguments, there will be an option to either create an object that stores those arguments until the rest of the arguments become known, or create a specialization of the function for these specific argument values. <i>Partial application</i>&nbsp;vs <i>partial evaluation</i>?</li>
<li>Support for currying and bind in some way.</li>
<li>Different function calls (with corresponding syntaxes?) to evaluate a function at compile and run-time.</li>
<li>Different function calls (with corresponding syntaxes?) to evaluate a function in a new (or existing?) thread and/or process.</li>
<li><b>Parameter pass modes (evaluation strategies?)</b></li>
<li style="list-style-type: none"><ul><li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Perhaps I can supply only the most generic parameter pass mode as build-in (tree?) and allow the rest to be created with constructors and conversions... e.g. every expression will be automatically converted into a tree and then converted into something else as needed.</li>
<li>It may be useful to have the ability to explicitly bind a variable with the return value of a function, perhaps by using <b>retval</b>. e.g. <tt>add(a, b, retval=c)</tt></li>
</ul>
</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Is the implementation of return by value equivalent to receiving a parameter by return? The return by external reference mode is equivalent to receiving a parameter by reference. But what about return by internal reference?</li>
<li style="list-style-type: none">Can I consider this to be a purely syntactic issue and use the functions either way? ((like with infix, method, etc.).</li>
<li>The following concepts have overlap. How many orthogonal concepts can I derive from them and what would they be?</li>
<li style="list-style-type: none"><ul><li>Mutability</li>
<li style="list-style-type: none"><ul><li>read-only</li>
<li>write-only</li>
<li>full-access</li>
</ul>
</li>
<li>Flow of information</li>
<li style="list-style-type: none"><ul><li>in</li>
<li>out</li>
<li>inout</li>
</ul>
</li>
<li>Evaluation strategy</li>
<li style="list-style-type: none"><ul><li>val</li>
<li>res</li>
<li>val res</li>
<li>ref</li>
<li>name</li>
<li>macro</li>
<li>need</li>
<li>tree?</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><b>Parameter Matching</b></li>
<li style="list-style-type: none"><ul><li>Support both positional and named parameters.</li>
<li>All named arguments not matching a named parameter will be passed as a map, like in Python.</li>
</ul>
</li>
<li><b>Default Arguments</b></li>
<li style="list-style-type: none"><ul><li>Should I be able to change default arguments when I create an alias for a function?</li>
</ul>
</li>
<li><b>Variadic functions</b></li>
<li style="list-style-type: none"><ul><li>Use of a unpack operator for arrays and maps like in Python (more generic than Java's mechanism).</li>
</ul>
</li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Maybe I can use the 0x2061 FUNCTION APPLICATION Unicode character to resolve the f(g+h) ambiguity.</li>
<li>What if a function call had 4 'kinds' of argument lists? (one for each member of a 'datum': value, type, name, address)</li>
<li>Should I allow for a default argument for be supplied by a virtual function of the same class? Generally changing default arguments in an function <u>override</u>&nbsp;isn't a good idea, but that way it might work!</li>
</ul>
</li>
</ul>
</li>
<li>May need functions that are able to change their argument type.</li>
<li style="list-style-type: none">In those cases, the initial and final type must implement the same interface. But what if I already have obtained a pointer to the variable of the old type?</li>
<li>Support for forwarding the return type. f()→auto&amp;, will deduce a reference return type (in general you'll be able to specify a pattern for the return type).</li>
<li>Allow deducing the return type even in functions with multiple return statements and recursive calls.</li>
<li><b>Polymorphism</b></li>
<li style="list-style-type: none"><ul><li>We can see a "polymorphic function" either as a set of monomorphic functions or as a function taking a number of type parameters.</li>
</ul>
</li>
<li><b>Overload Resolution</b></li>
<li style="list-style-type: none"><ul><li>In C++ when you declare a function in a scope, it hides all the functions with the same name in enclosing scopes, not only the one with the same signature. I don't think I wasn't that...</li>
<li style="list-style-type: none">On the other hand, I might need to explicitly remove names and signatures from selected scopes. (delete foo&lt;int&gt;?)</li>
</ul>
</li>
<li><b>Closures</b></li>
<li style="list-style-type: none"><ul><li>Lambda functions and closures might need to be stored in arrays.</li>
</ul>
</li>
<li><b>Implicitly Callable Functions</b></li>
<li style="list-style-type: none"><ul><li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Do I want to support them?</li>
<li>How do they interact with call by name? (is a thunk an ICF?)</li>
</ul>
</li>
</ul>
</li>
<li><b>Placeholder Arguments</b></li>
<li style="list-style-type: none"><ul><li>Can use arg[0]..arg[n] or $0..$n syntaxes.</li>
<li>Will evaluate to variadic functions.</li>
<li>Support for polymorphic lambdas.</li>
<li>Maybe I can couple <i>placeholder arguments</i>&nbsp;with type inference to concisely define functions like in functional programming languages. e.g. </li>
<li style="list-style-type: none"><tt>auto fact = $0 ≥ 1 ? fact($0-1)*$0 : 1;</tt></li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Should placeholder arguments be extended to work with named arguments as well as positional ones? (The names could be inferred from context)? e.g.</li>
<tt><li style="list-style-type: none">fun combine ∈ (leftRange ∈ range(T), rightRange ∈ range(S), combiner ∈ (left ∈ T, right ∈ S) ⟶ U) ⟶ range(U);</li>
<li style="list-style-type: none">...</li>
</tt><li style="list-style-type: none"><tt>combine([1,2,3,4],[0.1,0.2,0.3,0.4],2*$left + $right);</tt></li>
</ul>
</li>
</ul>
</li>
<li><b>Anonymous Functions</b>&nbsp;(lambda)</li>
<li style="list-style-type: none"><ul><li>Will support nesting. (unlike placeholder arguments?)</li>
<li>⟶ and λ functions. x ⟶ f() where x ∈ Identity(A⟶A)</li>
<li>polymorphic and variadic.</li>
<li>conversion to function pointer suitable for use as a callback.</li>
</ul>
</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Support a meta-object protocol?</li>
</ul>
</li>
</ul>
</body></html>