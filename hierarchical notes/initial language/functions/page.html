<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Functions</title>
</head><body><ul><li><b>Header</b></li>
<li style="list-style-type: none"><ul><li>Should a parameter be usable in defining the ones that follow? e.g.</li>
<li style="list-style-type: none">&#09;void f(T in Types, t in T)</li>
<li>In some cases, one might want to write a function that returns an array, but computing the array size will essentially be identical to running the function itself. In this case, the programmer will be able to use conventional methods (e.g. return a vector) or write a 2nd version of one's function that will perform all the computations, but won't write the result to an array, only return the size. One will then use this function to return the size of the array returned by the original function (essentially doubling the computations).</li>
<li style="list-style-type: none">Although repeating some computations twice isn't recommended, if the function is very fast (e.g. 60ns) and allocating memory in the heap is relatively slow (e.g. 1ms) then it will be reasonable for the programmer to prefer running the function 2 times and the language could help him by automatically generatinc a "dry-run" version of the function. The original function shall not read from the returned array (retval) (not even its size?) and writtes to the returned array will be compiled to no-ops in the dry-run version.</li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Allow or force the programmer to name all functions, be they called as infix operators, constructors, etc. or with a keyword like 'op' or 'operator' and the operator's symbol (e.g. op+). That should provide a little more documentation.</li>
<li>I can think of functions as taking a single argument and returning a single result (like in ML).</li>
<li style="list-style-type: none"><ul><li>Since I want to support named parameters, multiple parameters can be passed by means of a type that combines properties from both tuples and records.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>May need functions that are able to change their argument type.</li>
<li style="list-style-type: none">In those cases, the initial and final type must implement the same interface. But what if I already have obtained a pointer to the variable of the old type?</li>
<li>Support for forwarding the return type. f()→auto&amp;, will deduce a reference return type (in general you'll be able to specify a pattern for the return type).</li>
<li>Allow deducing the return type even in functions with multiple return statements and recursive calls.</li>
<li><b>Attributes</b></li>
<li style="list-style-type: none"><ul><li><b>Model</b></li>
<li style="list-style-type: none"><ul><li>All such attributes will be specifiable by the programmer using annotations/attributes.</li>
<li>All such attributes will be checkable by the compiler given some constraints about the function structure that will be documented.</li>
<li>Some of those attributes might be inferable by the compiler given some constraints about the function structure that will be documented.</li>
<li>The compiler <i>might</i>&nbsp;be able to check and/or infer such attributes even if the structure constraints are not met. (If they are met it is <i>required</i>&nbsp;to check and/or infer them)</li>
<li>It won't be an error to specify such attributes without meeting the documented constraints for checking and/or inference, but it may result to a warning.</li>
<li>Such attributes will be made part of the function interface (they may apply to the function itself or its type) and advertised in module headers.</li>
<li>The programmer <i>may</i>&nbsp;elect to specify that any additional attributes, not present in the code, that may be infered shall not be exported from the module as part of the function interface to ensure stability of the interface for the clients at the expence of lost chances for optimization.</li>
</ul>
</li>
<li><b>Attributes</b></li>
<li style="list-style-type: none"><ul><li>No escape of local addresses</li>
<li>Synchronized</li>
<li>Pureness / Referential Transparency</li>
<li style="list-style-type: none"><ul><li>Side Effect Free</li>
<li>Deterministic</li>
<li>Pure</li>
</ul>
</li>
<li>Side Effects</li>
<li>Leaf Status (optimization?)</li>
<li>Thrown Exceptions</li>
<li style="list-style-type: none"><ul><li>noexpept</li>
</ul>
</li>
<li>etc.</li>
</ul>
</li>
</ul>
</li>
<li><b>Body</b></li>
<li style="list-style-type: none"><ul><li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Allow the function body to be a single expression like in functional programming languages?</li>
<li>I could allow use of a keyword referring to a build-in function in place of the function body. e.g. IEEE-754-addition, machine-multiplication, machine-sqrt if available else &lt;body&gt;, etc.</li>
<li>Allow the function body to be a table with the associations (this might not be very useful if arrays can be substituted for functions). e.g.:</li>
<li style="list-style-type: none"><ul><tt><li style="list-style-type: none">finite</li>
<li style="list-style-type: none">{</li>
</tt></ul>
</li>
<tt><li style="list-style-type: none">&#09;a -&gt; .-</li>
<li style="list-style-type: none">&#09;b -&gt; -...</li>
<li style="list-style-type: none">&#09;c -&gt; -.-.</li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none">&#09;...</li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none">&#09;z -&gt; --..</li>
<li style="list-style-type: none">&#09;rest -&gt; ' '</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">}</li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none">or maybe</li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none">finite</li>
<li style="list-style-type: none">{</li>
</ul>
</li>
<li style="list-style-type: none">&#09;'a' -&gt; ".-"</li>
<li style="list-style-type: none">&#09;'b' -&gt; "-..."</li>
<li style="list-style-type: none">&#09;'c' -&gt; "-.-."</li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none">&#09;...</li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none">&#09;'z' -&gt; "--.."</li>
<li style="list-style-type: none">&#09;rest -&gt; " "</li>
</tt><li style="list-style-type: none"><ul><li style="list-style-type: none"><tt>}</tt></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><b>Polymorphism</b></li>
<li style="list-style-type: none"><ul><li>We can see a "polymorphic function" either as a set of monomorphic functions or as a function taking a number of type parameters.</li>
</ul>
</li>
<li><b>Overloading</b></li>
<li style="list-style-type: none"><ul><li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Should I allow overloading a function for different architectures? e.g.</li>
<li style="list-style-type: none"><ul><li>unsigned int populationCount(unsigned long long int) @ x86; // implement with architecture optimized code</li>
<li>unsigned int populationCount(unsigned long long int) @ MIPS; // implement with single machine instruction</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><b>Overload Resolution</b></li>
<li style="list-style-type: none"><ul><li>In C++ when you declare a function in a scope, it hides all the functions with the same name in enclosing scopes, not only the one with the same signature. I don't think I want that...</li>
<li style="list-style-type: none">On the other hand, I might need to explicitly remove names and signatures from selected scopes. (delete foo&lt;int&gt;?)</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Consider the interaction between overload resolution and implicit type conversions in the context of arithmetic types and their operators. e.g. Will 2l + 2ll work or be ambiguous?</li>
</ul>
</li>
</ul>
</li>
<li><b>Closures</b></li>
<li style="list-style-type: none"><ul><li>Lambda functions and closures might need to be stored in arrays.</li>
<li>Escaping closures (but only them) should cause the enclosing function's frame to be allocated on the garbage-collected heap.</li>
</ul>
</li>
<li><b>Implicitly Callable Functions</b></li>
<li style="list-style-type: none"><ul><li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Do I want to support them?</li>
<li>How do they interact with call by name? (is a thunk an ICF?)</li>
</ul>
</li>
</ul>
</li>
<li><b>Placeholder Arguments</b></li>
<li style="list-style-type: none"><ul><li>Can use arg[0]..arg[n] or $0..$n syntaxes.</li>
<li>Will evaluate to variadic functions.</li>
<li>Support for polymorphic lambdas.</li>
<li>Maybe I can couple <i>placeholder arguments</i>&nbsp;with type inference to concisely define functions like in functional programming languages. e.g. </li>
<li style="list-style-type: none"><tt>auto fact = $0 ≥ 1 ? fact($0-1)*$0 : 1;</tt></li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Should placeholder arguments be extended to work with named arguments as well as positional ones? (The names could be inferred from context)? e.g.</li>
<tt><li style="list-style-type: none">fun combine ∈ (leftRange ∈ range(T), rightRange ∈ range(S), combiner ∈ (left ∈ T, right ∈ S) ⟶ U) ⟶ range(U);</li>
<li style="list-style-type: none">...</li>
</tt><li style="list-style-type: none"><tt>combine([1,2,3,4],[0.1,0.2,0.3,0.4],2*$left + $right);</tt></li>
</ul>
</li>
</ul>
</li>
<li><b>Anonymous Functions</b>&nbsp;(lambda)</li>
<li style="list-style-type: none"><ul><li>Will support nesting. (unlike placeholder arguments?)</li>
<li>⟶ and λ functions. x ⟶ f() where x ∈ Identity(A⟶A)</li>
<li>polymorphic and variadic.</li>
<li>conversion to function pointer suitable for use as a callback.</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Select syntax. Could be:</li>
<li style="list-style-type: none"><ul><li>x -&gt; x**2</li>
<li>x --&gt; x**2</li>
<li>x =&gt; x**2</li>
<li>[](x){return x**2;}</li>
<li>λx. x**2</li>
<li>fn x =&gt; x**2</li>
<li>etc.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><b>Nested Functions</b></li>
<li style="list-style-type: none"><ul><li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Provide a uniform mechanism for capturing the environment be it global variables from global functions or local variables from local functions and lambdas.</li>
<li>Do I want a mechanism as powerful as C++'s lambda introducer?</li>
</ul>
</li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Accept the environment as one or more implicit parameters and allow explicitly specifying those parameters in the function signature to attach attributes and qualifiers. (like Java does with <b>this</b>)</li>
</ul>
</li>
</ul>
</li>
<li><b>Functions as Values</b></li>
<li style="list-style-type: none"><ul><li>I could allow binding an argument of n-parameter function type to a parameter of m-parameter function type (where m&lt;n), if the n-m parameters can get default values, by "auto-binding" the n-m parameters to their default values.</li>
</ul>
</li>
<li><b>Function Objects</b></li>
<li style="list-style-type: none"><ul><li>I'll probably have a build-in bind operator instead of function objects similar to those of C++. An object that appears as a function (after defining an operator for this syntax) will be passable as an argument to a higher-order function by being implicitly converted to a function by binding the object with the first parameter of the function call operator.</li>
</ul>
</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Support a meta-object protocol? Might be useful in defining C-like type coercions for arithmetic types since those types won't be build-in, but libraries.</li>
<li>Should function names behave as if they were variable names?</li>
</ul>
</li>
</ul>
</body></html>