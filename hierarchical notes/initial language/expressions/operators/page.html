<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Operators</title>
</head><body><ul><li>Include both symbolic operators and easy-to-type aliases for them.</li>
<li>If there are build-in operator and function definitions it should be possible to replace/override them, but keep them always available through some mechanism. (like C++'s new and delete)</li>
<li><b>List</b></li>
<li style="list-style-type: none"><ul><li><b>Type Expressions</b></li>
<li style="list-style-type: none"><ul><li style="list-style-type: none"><ul><li style="list-style-type: none">∁ (complement)</li>
</ul>
</li>
<li style="list-style-type: none">⟵</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">exponentiation ** (raise?)</li>
</ul>
</li>
<li style="list-style-type: none">⟶</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">cartesian product × (x) </li>
<li style="list-style-type: none">∩ (intersection)</li>
<li style="list-style-type: none">∪ (union)</li>
</ul>
</li>
<li style="list-style-type: none">⟵</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">procedure type? ⊣ (-|)</li>
<li style="list-style-type: none">function type ⟶ (--&gt;)</li>
<li style="list-style-type: none">= (equals), ≠ (not equals)</li>
</ul>
</li>
</ul>
</li>
<li><b>Unit Expressions</b></li>
<li style="list-style-type: none"><ul><li>multiplication ⋅ (*)</li>
<li>division /</li>
</ul>
</li>
<li><b>Value Expressions</b></li>
<li style="list-style-type: none"><ul><li>function call ()</li>
<li>pointers to members? (.*, .-&gt;)</li>
<li>dereferencing *, → (-&gt;)</li>
<li>∧ (and), ∨ (or), ¬ (not)</li>
<li>external product × (x) </li>
<li>internal product ⋅ (*)</li>
<li>In typeset contexts ∑ and ∏ should be available and they might have higher precedence than + and * respectively.</li>
<li>∩ (intersection), ∪ (union), ∁ (complement)</li>
<li>∈ (in), ∉ (not in), ⊆ (subset), ⊈ (not subset)</li>
<li>Also ⊂ and ⊄?</li>
<li>= (equals), ≠ (not equals)</li>
<li>&lt;, &gt;, ≤ (&lt;=), ≥ (&gt;=)</li>
</ul>
</li>
<li><b>Mixed Expressions</b></li>
<li style="list-style-type: none"><ul><li></li>
</ul>
</li>
</ul>
</li>
<li><b>Examples</b></li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">Arcadia type ⟺ closest C++ equivalent</li>
<li style="list-style-type: none"><ul><li>f:ℝ⟶ℝ ⟺ <tt>double f(double)</tt></li>
<li>ascii* ⟺ <tt>string</tt></li>
<li>unicode* ⟺ <tt>wstring</tt></li>
<li>ℕ ⟺ <tt>unsigned int</tt></li>
<li>ℕ×ℕ⟶ℕ ⟺ <tt>unsigned int (unsigned int, unsigned int)</tt></li>
</ul>
</li>
<li style="list-style-type: none">The above "types" can actually be interfaces that may have a default implementation and/or accept an implementation at use site.</li>
</ul>
</li>
<li><b>Type Composition</b></li>
<li style="list-style-type: none"><ul><li><b>Cartesian Product</b>&nbsp;(×)</li>
<li style="list-style-type: none"><ul><li>T₁×T₂×…×Tₙ concatenation, creates a tuple or struct with nameless members. Refer to specific members using indexing.</li>
</ul>
</li>
<li><b>Union</b>&nbsp;(∪)</li>
<li style="list-style-type: none"><ul><li>T₁∪T₂∪…∪Tₙ union, creates something like a C union but with anonymous members. Refer to specific members using indexing.</li>
</ul>
</li>
<li><b>Exponentiation</b>&nbsp;(**)</li>
<li style="list-style-type: none"><ul><li>Tⁿ exponentiation, equivalent to T×T×…×T n-times. Like an array. Again uses indexing.</li>
</ul>
</li>
<li><b>Postfix Asterisk</b>&nbsp;(*)</li>
<li style="list-style-type: none"><ul><li>T* &nbsp;Kleene's star, like a variable length array or a vector.</li>
<li>Could instead be used with the meaning it has in mathematical analysis textbooks, i.e. to remove zero from a set.</li>
</ul>
</li>
<li><b>Function Definition</b>&nbsp;(⟶)</li>
<li style="list-style-type: none"><ul><li>T₁⟶T₂ creates a function type.</li>
</ul>
</li>
</ul>
</li>
<li><b>Arithmetic</b></li>
<li><b>Exponentiation</b></li>
<li><b>Logical</b></li>
<li style="list-style-type: none"><ul><li>Include a <tt>xor</tt>&nbsp;operator.</li>
<li>Support short-circuiting of logical operators.</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Should I make a distinction between <tt>and</tt>&nbsp;/ <tt>and then</tt>&nbsp;and <tt>or</tt>&nbsp;/ <tt>or else</tt>&nbsp;like Ada does? (the latter being the short-circuited version)</li>
<li>Should <b>a || b</b>&nbsp;and <b>a &amp;&amp; b </b>return one of a, b instead of a truth value like they do in Python?</li>
</ul>
</li>
</ul>
</li>
<li><b>Null Coalescing</b></li>
<li style="list-style-type: none"><ul><li>Should I include the '??' operator from C#?</li>
</ul>
</li>
<li><b>Null-Conditional</b></li>
<li style="list-style-type: none"><ul><li>Should I include the '?.' and '?[' operators from C#?</li>
</ul>
</li>
<li><b>Assignment</b></li>
<li style="list-style-type: none"><ul><li>Use the ↜ and &lt;~ operators.</li>
<li>Will support modification-assignments</li>
<li>Will support expressions like <tt>(temp -= 32) *= 5/9</tt>.</li>
<li>Support simultaneous assignment.</li>
<li>Should be elidable.</li>
<li>Could provide different operators for shallow and deep assignment.</li>
<li style="list-style-type: none"><ul><li>In most situations mutating a shallow copy invalidates all others and deallocating one should prevent others from deallocating the same memory. So a move that invalidates the source object might be preferable.</li>
</ul>
</li>
<li>There are two options:</li>
<li style="list-style-type: none"><ul><li>↜ denotes deep copy and move is signaled by using a function (C++). e.g.</li>
<li style="list-style-type: none"><ul><tt><li style="list-style-type: none">v = u; // copy</li>
</tt><li style="list-style-type: none"><tt>v = move(u); // move</tt></li>
</ul>
</li>
<li>↜ denotes move (shallow copy + invalidation) and copy is signaled by using a function (Rust). e.g.</li>
<li style="list-style-type: none"><ul><tt><li style="list-style-type: none">v = u.copy(); // copy</li>
</tt><li style="list-style-type: none"><tt>v = u; // move</tt></li>
</ul>
</li>
</ul>
</li>
<li style="list-style-type: none">In any case, a modifier function is preferable to a 2nd operator because it can be used to change how arguments are passed as well.</li>
</ul>
</li>
<li><b>Equality</b>&nbsp;(=,≠)</li>
<li style="list-style-type: none"><ul><li>May need multiple versions:</li>
<li style="list-style-type: none"><ul><li>shallow</li>
<li>deep</li>
<li>binary</li>
</ul>
</li>
</ul>
</li>
<li><b>Object Membership</b>&nbsp;(.)</li>
<li style="list-style-type: none"><ul><li>I is preferable that '.' be able to distinguish between bgcolor.red and bgcolor."red" at compile-time. Of course, if field identifiers are implemented as integers, (from which you'll be able to get the names too e.g. using an array) this shouldn't be a problem.</li>
<li>To guarantee that the object membership operator (.) is as fast as in languages where it's build-in, I'll need a form of partial evaluation where some of the function arguments are known during compile-time while others are not.</li>
</ul>
</li>
<li><b>Array Subscript</b></li>
<li style="list-style-type: none"><ul><li>I might not need $ (from D), if I adopt Python's approach of using negative offsets (added to the array's length).</li>
<li>$ might be preferable. In any case, this is more of a library issue.</li>
</ul>
</li>
<li><b>Comprehensions</b></li>
<li style="list-style-type: none"><ul><li>Expand the mathematical syntax for creating sets as subsets of other sets to lists and maps. Python calls this 'comprehension'.</li>
</ul>
</li>
<li><b>~</b>&nbsp;for regular expression matching?</li>
<li><b>nothrow</b>&nbsp;(or likewise named) operator takes an expression and returns false iff the expression could never throw an exception.</li>
<li><b>precedenceof</b>&nbsp;for defining an operator with the same precedence as another one.</li>
<li><b>is</b>&nbsp;or <b>instanceof</b>&nbsp;operator to check the dynamic type of an expression against a static type or interface.</li>
<li style="list-style-type: none"><ul><li>Always returns false for null expressions.</li>
<li>Causes a compile-time warning if the expression is known to always be <tt>true</tt>&nbsp;or to always be <tt>false</tt>, but typically evaluates type compatibility at run time.</li>
</ul>
</li>
<li><b>as</b>&nbsp;operator </li>
<li><b>ring operator </b>(∘) for function composition and appending sequences (including strings).</li>
<li><b>range operator</b>&nbsp;(..) for specifying ranges a..b returns a range containing the numbers from a to but not including b. 3..5 := [3,4]</li>
<li><b>sequence operator</b>&nbsp;(, ,..., ) for specifying sequences and progressions. Automatically recognises arithmetic and geometric progressions. e.g.</li>
<li style="list-style-type: none"><ul><li>1,...,3 := [1,2,3] (one initial term means arithmetic progression with unit step)</li>
<li>1,2,...,10 := [1,2,3,4,5,6,7,8,9,10] (two initial terms means arithmetic progression)</li>
<li>1,2,4,...,64 := [1,2,4,8,16,32,64] (three initial terms means geometric progression)</li>
<li>1, 3, 2*$x+1,..., 9 := [1,3,5,7,9] (a function after initial terms is used for computing all terms. No equation is solved. Checks are performed to ensure the function maps 0 to the first term, 1 to the second term and so on)</li>
</ul>
</li>
<li><b>interval operator </b>([,(,),]) for specifying intervals of real numbers.</li>
<li style="list-style-type: none"><ul><li><tt>[a,b]</tt>, <tt>(a,b]</tt>, <tt>(a,b)</tt>, <tt>[a,b)</tt>&nbsp;could be interpreted as {x∈ℝ : a≤x≤b}, {x∈ℝ : a&lt;x≤b}, {x∈ℝ : a&lt;x&lt;b}, {x∈ℝ : a≤x&lt;b} respectively.</li>
<li><tt>[a,b]:n</tt>&nbsp;could be interpreted as Matlab's linspace(a,b,n), i.e. evaluate to a range containing n evenly spaced points between and including the endpoints a and b.</li>
<li><tt>[a,b|d]</tt>&nbsp;could evaluate to a range x₁=a, x₂=x₁+d, x₃=x₂+d,...,xₙ=b, of as many d-spaced points as are needed to fill the distance between the endpoint a and b.</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>How do I resolve ambiguities when used in conjunction with tuples and lists?</li>
</ul>
</li>
</ul>
</li>
<li><b>mixin</b>&nbsp;(from D) or similar operator (Python and JavaScript have <i>eval</i>) that accepts a string and compiles it as if it was code appearing in place of the operator. My syntax can be of the form <tt>&lt;[</tt><i>expression</i><tt>]&gt;</tt>.</li>
<li><b>compile</b>&nbsp;<i>expression</i>&nbsp;<b>end</b><i>&nbsp;</i>(could also end with ";" or something else) that evaluates <i>expression</i>&nbsp;(which must evaluate to an AST) during compile-time and forwards the AST for attachment to the broader AST of the program and for semantic analysis, translation, etc.</li>
<li><b>operator </b>or <b>op</b>&nbsp;or <b>''</b><i>operator</i><b>''</b></li>
<li style="list-style-type: none"><ul><li>Should an operator like that exist to force another operator to loose its operator status and allow reference to the operator itself like passing it to a function that expects another function as an argument?</li>
<li>The syntax <b>op</b>&nbsp;<i>operator_symbol</i>&nbsp;should work with all operators and their overloads even if those are defined for fundamental types (e.g. operator+(int, int)). i.e. the example shouldn't issue an error like in C++.</li>
</ul>
</li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Allow indexing of arrays, maps, vectors, matrices and random access ranges (everything that supports the index-of operator) using ranges of indices! (this supersedes the {i₁, i₂,...,iₙ} notation)</li>
<li>An alternative notation could be something like .1-5,7.</li>
<li>The .x, .y, .xy, .zxy, etc. OpenCL notation can still apply for a finite number of named indices.</li>
<li>Should I include sed commands in addition to regular expressions? (s/foo/bar in addition to /(foo|bar)*/)</li>
<li>Include matlab-like operator or function to produce equidistant points in a range of real numbers for use in plots, etc.</li>
<li><b>:asclass</b>&nbsp;postfix operator that returns an object that describes the type in a form suitable for use by the program.</li>
<li><b>:astype</b>&nbsp;postfix operator that returns the type described by its argument in a form suitable for use by the compiler. e.g.</li>
<li style="list-style-type: none"><ul><tt><li style="list-style-type: none">x ∈ ℝ ⟺ x ∈ ℝ &nbsp; &nbsp; &nbsp;⟺ x ∈ ℝ</li>
</tt><li style="list-style-type: none"><tt>y ∈ ℝ &nbsp; &nbsp;y ∈ x:type &nbsp; &nbsp;y ∈ x:type:asclass:astype</tt></li>
</ul>
</li>
<li><b>:tree</b>&nbsp;postfix operator that returns the expression given as its argument in the form of an AST. e.g.</li>
<li style="list-style-type: none"><ul><li><tt>compile #derivative(&lt;| return x</tt>²<tt>+3x+2; |&gt;:tree) end;</tt></li>
<li><b>Use Cases</b>:</li>
<li style="list-style-type: none"><ul><li>Provide the ASTs to feed to symbolic differentiation routines. e.g. If a function's body is a single expression, then the function could be converted to an AST for this expression. The AST would be converted to another AST during compilation and from that, to a new function representing the derivative.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Clarify the semantics of the range operator (..). 0..3 means [0,1,2,3] or [0,1,2]?</li>
</ul>
</li>
</ul>
</body></html>