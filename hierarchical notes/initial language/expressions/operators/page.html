<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Operators</title>
</head><body><ul><li>Include both symbolic operators and easy-to-type aliases for them.</li>
<li>List</li>
<li style="list-style-type: none"><ul><li>function call ()</li>
<li>pointers to members? (.*, .-&gt;)</li>
<li>function type ⟶ (--&gt;)</li>
<li>procedure type? ⊣ (-|)</li>
<li>dereferencing *, → (-&gt;)</li>
<li>∧ (and), ∨ (or), ¬ (not)</li>
<li>∩ (intersection), ∪ (union), ∁ (complement)</li>
<li>∈ (in), ∉ (not in), ⊆ (subset), ⊈ (not subset), = (equals), ≠ (not equals)</li>
<li>Also ⊂ and ⊄?</li>
<li>In typeset contexts ∑ and ∏ should be available and they might have higher precedence than + and * respectively.</li>
</ul>
</li>
<li>If there are build-in operator and function definitions it should be possible to replace/override them, but keep them always available through some mechanism. (like C++'s new and delete)</li>
<li><b>Arithmetic</b></li>
<li><b>Exponentiation</b></li>
<li><b>Logical</b></li>
<li style="list-style-type: none"><ul><li>Include a <tt>xor</tt>&nbsp;operator.</li>
<li>Support short-circuiting of logical operators.</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Should I make a distinction between <tt>and</tt>&nbsp;/ <tt>and then</tt>&nbsp;and <tt>or</tt>&nbsp;/ <tt>or else</tt>&nbsp;like Ada does? (the latter beign the short-circuited version)</li>
<li>Should <b>a || b</b>&nbsp;and <b>a &amp;&amp; b </b>return one of a, b instead of a truth value like they do in Python?</li>
</ul>
</li>
</ul>
</li>
<li><b>Null Coalescing</b></li>
<li style="list-style-type: none"><ul><li>Should I include the '??' operator from C#?</li>
</ul>
</li>
<li><b>Null-Conditional</b></li>
<li style="list-style-type: none"><ul><li>Should I include the '?.' and '?[' operators from C#?</li>
</ul>
</li>
<li><b>Assignment</b></li>
<li style="list-style-type: none"><ul><li>Use the ↜ and &lt;~ operators.</li>
<li>Will support modification-assignments</li>
<li>Will support expressions like <tt>(temp -= 32) *= 5/9</tt>.</li>
<li>Support simultaneous assignment.</li>
<li>Should be elidable.</li>
<li>Provide different operators for shallow and deep assignment.</li>
</ul>
</li>
<li><b>Object Membership</b>&nbsp;(.)</li>
<li style="list-style-type: none"><ul><li>I is preferable that '.' be able to distinguish between bgcolor.red and bgcolor."red" at compile-time. Of course, if field identifiers are implemented as integers, (from which you'll be able to get the names too e.g. using an array) this shouldn't be a problem.</li>
<li>To guarantee that the object membership operator (.) is as fast as in languages where it's build-in, I'll need a form of partial evaluation where some of the function arguments are known during compile-time while others are not.</li>
</ul>
</li>
<li><b>Array Subscript</b></li>
<li style="list-style-type: none"><ul><li>I might not need $ (from D), if I adopt Python's approach of using negative offsets (added to the array's length).</li>
<li>$ might be preferable. In any case, this is more of a library issue.</li>
</ul>
</li>
<li><b>Comprehensions</b></li>
<li style="list-style-type: none"><ul><li>Expand the mathematical syntax for creating sets as subsets of other sets to lists and maps. Python calls this 'comprehension'.</li>
</ul>
</li>
<li><b>~</b>&nbsp;for regular expression matching?</li>
<li><b>nothrow</b>&nbsp;(or likewise named) operator takes an expression and returns false iff the expression could never throw an exception.</li>
<li><b>precedenceof</b>&nbsp;for defining an operator with the same precedence as another one.</li>
<li><b>is</b>&nbsp;or <b>instanceof</b>&nbsp;operator to check the dynamic type of an expression against a static type or interface.</li>
<li style="list-style-type: none"><ul><li>Always returns false for null expressions.</li>
<li>Causes a compile-time warning if the expression is known to always be <tt>true</tt>&nbsp;or to always be <tt>false</tt>, but typically evaluates type compatibility at run time.</li>
</ul>
</li>
<li><b>as</b>&nbsp;operator </li>
<li><b>ring operator </b>(∘) for function composition and appending sequences (including strings).</li>
<li><b>range operator</b>&nbsp;(..) for specifying ranges a..b returns a range containing the numbers from a to but not including b. 3..5 := [3,4]</li>
<li><b>sequence operator</b>&nbsp;(, ,..., ) for specifying sequences and progressions. Automatically recognises arithmetic and geometric progressions. e.g.</li>
<li style="list-style-type: none">1,2,...,10 := [1,2,3,4,5,6,7,8,9,10] (two initial terms means arithmetic progression)</li>
<li style="list-style-type: none">1,2,4,...,64 := [1,2,4,8,16,32,64] (three initial terms means geometric progression)</li>
<li style="list-style-type: none">1, 3, 2*$x+1,..., 9 := [1,3,5,7,9] (a function after initial terms is used for computing all terms. No equation is solved. Checks are done to ensure the function maps 0 to the first term, 1 to the second term and so on)</li>
<li><b>mixin</b>&nbsp;(from D) or similar operator (Python and JavaScript have <i>eval</i>) that accepts a string and compiles it as if it was code appearing in place of the operator. My syntax can be of the form <tt>&lt;[</tt><i>expression</i><tt>]&gt;</tt>.</li>
<li><b>operator </b>or <b>op</b>&nbsp;or <b>''</b><i>operator</i><b>''</b></li>
<li style="list-style-type: none"><ul><li>Should an operator like that exist to force another operator to loose its operator status and allow reference to the operator itself like passing it to a function that expects another function as an argument?</li>
<li>The syntax <b>op</b>&nbsp;<i>operator_symbol</i>&nbsp;should work with all operators and their overloads even if those are defined for fundamental types (e.g. operator+(int, int)). i.e. the example shouldn't issue an error like in C++.</li>
</ul>
</li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Allow indexing of arrays, maps, vectors, matrices and random access ranges (everything that supports the index-of operator) using ranges of indices! (this supersedes the {i₁, i₂,...,iₙ} notation)</li>
<li>An alternative notation could be something like .1-5,7.</li>
<li>The .x, .y, .xy, .zxy, etc. OpenCL notation can still apply for a finite number of named indices.</li>
<li>Should I include sed commands in addition to regular expressions? (s/foo/bar in addition to /(foo|bar)*/)</li>
<li>Include matlab-like operator or function to produce equidistant points in a range of real numbers for use in plots, etc.</li>
</ul>
</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Clarify the semantics of the range operator (..). 0..3 means [0,1,2,3] or [0,1,2]?</li>
</ul>
</li>
</ul>
</body></html>