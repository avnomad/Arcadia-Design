<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Declarations</title>
</head><body><ul><li>Variables should be declared before they are used.</li>
<li>In contexts where expression statements are needed I need <b>auto</b>&nbsp;(or <b>var</b>&nbsp;or something similar) to distinguish between declarations/definitions and expression statements. In contexts like global declarations or field declarations it might not be needed, but I may want to maintain uniformity anyway...</li>
<li><b>Variables</b></li>
<li style="list-style-type: none"><ul><li>Also applies to structure field declarations.</li>
<li><b>Syntax</b></li>
<li style="list-style-type: none"><ul><li>Could start the declaration with the storage class specifier instead of a keyword like 'var' or 'val'.</li>
<li>Could also put the declaration between two verticals (|) (like Smalltalk), but I may want to leave '|' available for other things.</li>
</ul>
</li>
<li><b>Initializers</b></li>
<li style="list-style-type: none"><ul><li><b>Designated initializers</b></li>
<li style="list-style-type: none"><ul><li>Will be replaced by a more general mechanism.</li>
</ul>
</li>
<li><b>Value Range Propagation</b></li>
<li style="list-style-type: none"><ul><li>Use of Value Range Propagation to check statically whether the value of the expression used as the initializer is within the allowed values for the variable's type.</li>
<li style="list-style-type: none"><ul><li>An older idea for implementing this without making arithmetic types build-in, was to automatically add the 'literal' qualifier to the literal's type by the compiler and pass them to user-defined functions that would covert them from strings to numbers taking any suffixes (like C's f,s, etc.) into account.</li>
</ul>
</li>
<li>D uses VRP only within a single expression, but I could do it between expressions as well.</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Can it be implemented using primitives of the existing type system?</li>
<li>Can it be combined with liquid types?</li>
</ul>
</li>
</ul>
</li>
<li>Allow initializing with 'nothing' to leave a variable uninitialized. (like D does with <tt>void</tt>)</li>
<li>If a variable declaration has no initializer I can:</li>
<li style="list-style-type: none"><ul><li>Leave it uninitialized (C, C++).</li>
<li>Initialize it with some type-dependent default (Java, D, Protobuf).</li>
<li>Issue an error message.</li>
<li>Try to prove it gets initialized between declaration and first use, and if I can't, then issue an error message.</li>
</ul>
</li>
</ul>
</li>
<li><b>Qualifiers</b></li>
<li><b>Storage Class Specifiers</b></li>
<li><b>Alignment</b></li>
<li style="list-style-type: none"><ul><li>An alignment significantly larger than a variables' size, can be useful to force it to occupy a caché line by itself, so that writes in that line wouldn't invalidate others in a multiprocessor!</li>
<li>Do I want to support packed arrays and how will they interact with alignment?</li>
<li>What about padding and bit-fields?</li>
</ul>
</li>
<li><b>Endianness</b></li>
<li><b>Offset</b></li>
<li><b>Interface Type</b></li>
<li style="list-style-type: none"><ul><li>Support declaring variables of interface type. Using a dynamic interface for a variable's type is common in Java, but static interfaces will be more interesting.</li>
<li>Using an interface where a type is expected in a variable (or parameter) declaration could cause the function to become a template. Then, at the call site, the missing types could be inferred from the arguments, specified using some syntax, or given some default value. It could also be declared that a given type will become known during run-time and thus, dynamic dispatch must be used. The latter could be declared as the default behaviour.</li>
<li>It might be possible to allow changing a variable's type after its definition using a special class of functions (or with a special syntax). Those functions would be responsible for doing the conversion under the hood. I could demand that the initial and final type implement the same interface, but they definitely need to have the same size (unless I allocate the maximum of the two sizes up-front...).</li>
<li style="list-style-type: none"><ul><li><b>Use cases</b></li>
<li style="list-style-type: none"><ul><li>Changing the coordinate system used internally to store a complex number (e.g. cartesian ⟷ polar).</li>
<li>Changing the base used internally to store a polynomial (e.g. power basis form ⟷ bézier form).</li>
<li>Changing the color space used internally to store a color. (e.g. RGB ⟷ HSV).</li>
<li>In all the above cases the functions optimized for the new representation will be used after the change.</li>
<li>May be usable with unions too.</li>
</ul>
</li>
</ul>
</li>
<li>An alternative could be to just allow assigning a value of a different type to a variable of interface type.</li>
</ul>
</li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Should variables be immutable by default? Search open-source code to see which is most common!</li>
<li>Should all variables, or a subset of them (e.g. statics are initialized to 0 in ELF and EXE anyway), be initialized to zero by default?</li>
<li><b>RAII</b></li>
<li style="list-style-type: none"><ul><li>Should I allow the definition of nameless variables? e.g. for calling the constructor and destructor.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><b>Types</b></li>
<li style="list-style-type: none"><ul><li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>In the definition of a type, a representation could be required and both build-in and user-defined ones could be accepted. e.g. 32bit-2s-complement, native-signed-integer-no-saturation, IEEE-754-signle, ASCII, etc.</li>
</ul>
</li>
</ul>
</li>
<li><b>Aliases</b></li>
<li style="list-style-type: none"><ul><li>Allow type, variable, function, etc. aliases.</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Clarify semantics of <tt>auto aNewName = transmogrify;</tt>&nbsp;in the case where transmogrify is an overloaded function.</li>
</ul>
</li>
</ul>
</li>
<li><b>Functions</b></li>
<li style="list-style-type: none"><ul><li>The order in which function definitions appear is not important and declarations are optional. This might imply compilation in multiple passes.</li>
<li>Declarations are intended mostly for cases where the definition is not available in source code but only in object code.</li>
</ul>
</li>
</ul>
</body></html>