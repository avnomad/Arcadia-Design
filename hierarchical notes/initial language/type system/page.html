<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Type System</title>
</head><body><ul><li>We can see a "type" in different ways:</li>
<li style="list-style-type: none"><ul><li>As a set of values.</li>
<li>As a set of supported operations.</li>
<li>As an interpretation of the binary data stored in some memory locations.</li>
<li>As the expression tree used to create it.</li>
</ul>
</li>
<li>Allow using a type as a set of values and vice versa! e.g.</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">array ⟷ enumeration</li>
<li style="list-style-type: none">range ⟷ subrange type</li>
<li style="list-style-type: none">etc.</li>
</ul>
</li>
<li>Support for subrange types does not necessarily mean that the following cases will be supported out-of-the-box:</li>
<li style="list-style-type: none"><ul><li><tt>val a ∈ −∞..−1 ∪ 1..∞ = 15;</tt></li>
<tt><li style="list-style-type: none">val b ∈ {x ∈ ℤ : x ≠ 0};</li>
<li style="list-style-type: none">b = a;</li>
</tt><li><tt>val a ∈ ℤ;</tt></li>
<tt><li style="list-style-type: none">val b ∈ {x ∈ ℤ : x ≠ 0};</li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none">if a ≠ 0:</li>
</tt><li style="list-style-type: none"><ul><li style="list-style-type: none"><tt>b = a;</tt></li>
</ul>
</li>
</ul>
</li>
<li>Types may be parameterized by expressions that need to be checked statically, evaluated at run-time and affect the type's size.</li>
<li style="list-style-type: none"><ul><li>An example is array types.</li>
<li style="list-style-type: none"><ul><li><b>Use cases</b></li>
<li style="list-style-type: none"><ul><li>string operations (e.g. concatenation)</li>
<li>vector operations (e.g. addition)</li>
<li>spline operations (e.g. raise or lower degree, evaluate, etc.)</li>
<li>OS APIs (e.g. functions that need you to call them once to get the size of an array, allocate the array and call them again with the array)</li>
</ul>
</li>
</ul>
</li>
<li>Matching array types may require solving systems of linear equations.</li>
<li style="list-style-type: none">e.g. If <tt>f ∈ T ⟶ (int[n], uint[n+10])</tt>&nbsp;and <tt>g ∈ (int[m−10], uint[m])</tt>, then g(f(x)) might need to solve the system</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">l1 = n</li>
<li style="list-style-type: none">l2 = n+10</li>
<li style="list-style-type: none">l3 = m-10</li>
<li style="list-style-type: none">l4 = m</li>
<li style="list-style-type: none">n = m-10</li>
<li style="list-style-type: none">n+10 = m</li>
</ul>
</li>
<li style="list-style-type: none">assuming l1, l2 and n are known and l3, l4 and m are unknowns. It should conclude that the system has exactly one solution (expressed as a function of one of the knowns), namely l4=m=n+10 and l3 = n.</li>
</ul>
</li>
<li>It might be necessary to include prefix, postfix, infix, function, method, etc. as part of the (function) type.</li>
<li>Should be able to check various attributes like:</li>
<li style="list-style-type: none"><ul><li>thrown exceptions</li>
<li>pureness</li>
<li>other?</li>
</ul>
</li>
<li><b>Type Inference</b></li>
<li style="list-style-type: none"><ul><li>Haskell is probably capable of inferring type classes. Can I use something like that?</li>
<li>Ability to infer various attributes like:</li>
<li style="list-style-type: none"><ul><li>thrown exceptions</li>
<li>pureness</li>
<li>other?</li>
</ul>
</li>
</ul>
</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>What are the operations required from a type?</li>
<li style="list-style-type: none"><ul><li>Size, alignment, default value, etc.? (for allocation)</li>
<li>Test for membership? (for initialization with literal)</li>
<li>Test for equality? (for assignment)</li>
<li>Test for compatibility with another type? (for assignment)</li>
<li>Deconstruction? (for inferring template arguments)</li>
</ul>
</li>
<li>How do type qualifiers effect things?</li>
<li style="list-style-type: none"><ul><li>Experience with Java static checkers may help</li>
<li style="list-style-type: none"><ul><li>Problem with Java non-null analysis and maps. Merging of qualifiers?</li>
</ul>
</li>
</ul>
</li>
<li>There must be a theory (lambda calculus?) that describes values, types, polymorphism, type constructors (of higher-order too), types that depend on values and all the above together!</li>
<li>Learn more about <i>liquid types</i>.</li>
</ul>
</li>
</ul>
</body></html>