<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Statements</title>
</head><body><ul><li><b>Control Structures</b></li>
<li style="list-style-type: none"><ul><li>All control structures will be executable at compile time as well and usable in global and class definition contexts .</li>
<li><b>Syntax</b></li>
<li style="list-style-type: none"><ul><li><tt>+if +while +for +foreach +block</tt></li>
<tt><li style="list-style-type: none">−if −while −for −foreach −block</li>
</tt><li>+for, -for για μεγάλο σώμα, for για μικρό (ένα expression statement ή break κτλ.)</li>
</ul>
</li>
<li><b>Loops</b></li>
<li style="list-style-type: none"><ul><li>Support '<b>else</b>' clause in loop statements, like in Python.</li>
<li><b>Foreach</b></li>
<li style="list-style-type: none"><ul><li>Should be able to modify elements (by default?).</li>
<li>Will expect a range to iterate over.</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Should they be able to simultaneously generate indices and values while iterating a collection, like in D?</li>
<li>Should it be possible to overload the foreach loop with <i>iteration primitives</i>&nbsp;and <i>internal iteration</i>&nbsp;like in D?</li>
<li style="list-style-type: none">Basically what D does isn't operator overload, but expression rewrites and lowering like those of an AST preprocessor!</li>
<li>How will a static foreach loop that iterates over all members of a tuple/record behave? Will it always unroll?</li>
</ul>
</li>
</ul>
</li>
<li><b>Forever</b></li>
<li><b>For</b></li>
<li style="list-style-type: none"><ul><li>Do I need it?</li>
<li><b>Syntax</b></li>
<li style="list-style-type: none"><ul><li style="list-style-type: none"><tt>+for(</tt>&nbsp;<i>expression</i>&nbsp;<tt>)</tt></li>
<li style="list-style-type: none"><ul><li style="list-style-type: none"><i>statement-sequence</i></li>
</ul>
</li>
<tt><li style="list-style-type: none">−for</li>
<li style="list-style-type: none"></li>
</tt><li style="list-style-type: none"><tt>+for(</tt>&nbsp;<i>expression</i>&nbsp;<tt>):</tt>&nbsp;<i>identifier</i></li>
<li style="list-style-type: none"><ul><li style="list-style-type: none"><i>statement-sequence</i></li>
</ul>
</li>
<li style="list-style-type: none"><tt>−for: <i>identifier</i></tt></li>
</ul>
</li>
</ul>
</li>
<li><b>While</b></li>
<li><b>Do-while</b></li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Include <b>unless</b>, <b>until</b>, etc?</li>
<li>Include a loop of the form:</li>
<li style="list-style-type: none"><ul><tt><li style="list-style-type: none">do</li>
</tt><li style="list-style-type: none"><ul><li style="list-style-type: none"><i>block</i></li>
</ul>
</li>
<li style="list-style-type: none"><i>natural-number</i><tt>&nbsp;times;</tt></li>
</ul>
</li>
<li>Include components that can be combined to create loops similar to Ada's. e.g. <tt>+loop</tt>, −loop, <tt>while(...)</tt>, <tt>until(...)</tt>, etc. With <tt>while</tt>&nbsp;and <tt>until</tt>&nbsp;being placeable at both the beginning or the end of the loop construct after the 'loop' keyword.</li>
</ul>
</li>
</ul>
</li>
<li><b>Conditionals</b></li>
<li style="list-style-type: none"><ul><li><b>If</b></li>
</ul>
</li>
<li><b>Case</b>&nbsp;/ <b>Switch</b></li>
<li style="list-style-type: none"><ul><li>The default behaviour when reaching the end of a case block will be to transfer control to the instruction just after the case/switch body.</li>
<li>Include an optional <tt>default</tt>&nbsp;case.</li>
<li>Include a <tt>fallthrough</tt>&nbsp;statement for "falling of" to the next case. (to allow behaviour similar to C's)</li>
</ul>
</li>
</ul>
</li>
<li><b>Expression Statements</b></li>
<li style="list-style-type: none"><ul><li><b>Empty Statement</b></li>
<li style="list-style-type: none"><ul><li>Do I need one?</li>
<li>How can I avoid errors of the form <tt>for(...);</tt>?</li>
<li>Perhaps I can lack an empty statement, but instead use a statement that does nothing by convention like <tt>null;</tt>.</li>
<li>D includes an empty statement but bans it from control statements like for. Proposes using an empty block instead.</li>
</ul>
</li>
</ul>
</li>
<li><b>Labels</b></li>
<li style="list-style-type: none"><ul><li>Support labelling statements for use with <b>goto</b>, <b>break</b>&nbsp;and <b>continue</b>.</li>
<li>Another (preferable) idea is to only support named blocks and not labelling of arbitrary statements. Instead of labelling a statement, you wrap it in a named block.</li>
<li>Could allow labelling of block-like versions of control structures too, or just blocks (preferable).</li>
<li>Labels don't need to be at the line start.</li>
</ul>
</li>
<li><b>Return</b></li>
<li style="list-style-type: none"><ul><li><tt>return</tt>&nbsp;<i>expression</i><tt>;</tt>&nbsp;will be equivalent to <tt>retval = </tt><i>expression</i><tt>; return;</tt>.</li>
<li>A <tt>return</tt>&nbsp;statement isn't required if an explicit assignment has been made to <tt>retval</tt>.</li>
<li>"Falling off" the end of a function has the same effect as returning.</li>
</ul>
</li>
<li><b>Jump Statements</b></li>
<li style="list-style-type: none"><ul><li><b>Goto</b></li>
<li style="list-style-type: none"><ul><li><tt>goto</tt>&nbsp;<b>(</b><tt>begin</tt>&nbsp;<b>|</b>&nbsp;<tt>end</tt><b>)</b>&nbsp;<i>block-name</i></li>
<li><tt>goto</tt><i>&nbsp;</i><b>(</b><tt>begin</tt>&nbsp;<b>|</b>&nbsp;<tt>end</tt><b>)</b><i>&nbsp;</i><b>[</b><i>nesting-level</i><b>]</b></li>
<li style="list-style-type: none"><ul><li><i>nesting-level</i>&nbsp;is an integer that defaults to 0. All control and other structures that introduce scopes count towards increasing the nesting-level.</li>
<li>Can't jump from a for to another that doesn't enclose the first. For that, you need a named block.</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Is the level system more likely to lead to errors that are not detectable by the compiler than labels?</li>
</ul>
</li>
</ul>
</li>
<li><tt>goto</tt><i>&nbsp;</i><b>(</b><tt>begin</tt>&nbsp;<b>|</b>&nbsp;<tt>end</tt><b>)</b><i>&nbsp;</i><b>(</b><tt>if</tt>&nbsp;<b>|</b>&nbsp;<tt>for</tt>&nbsp;<b>|</b>&nbsp;<tt>foreach</tt>&nbsp;<b>|</b>&nbsp;<tt>while</tt>&nbsp;<b>|</b>&nbsp;<tt>do</tt>&nbsp;<b>|</b>&nbsp;...<b>)<tt>&nbsp;</tt>[</b><i>nesting-level</i><b>]</b></li>
<li style="list-style-type: none"><ul><li>This version only counts nestings of the mentioned control structure towards increasing the nesting-level. So e.g.</li>
<li style="list-style-type: none"><ul><tt><li style="list-style-type: none">+for // level 1</li>
</tt><li style="list-style-type: none"><ul><tt><li style="list-style-type: none">+if</li>
</tt><li style="list-style-type: none"><ul><tt><li style="list-style-type: none">+for // level 0</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">goto end for 1;</li>
</ul>
</li>
</tt><li style="list-style-type: none"><tt>−</tt>for</li>
</ul>
</li>
<li style="list-style-type: none"><tt>−</tt>if</li>
</ul>
</li>
<li style="list-style-type: none"><tt>−</tt>for</li>
</ul>
</li>
</ul>
</li>
<li>No label targets</li>
</ul>
</li>
<li><b>Break</b></li>
<li style="list-style-type: none"><ul><li>Equivalent to <tt>goto for end;</tt>, <tt>goto while end;</tt>, etc. depending on the enclosing loop.</li>
</ul>
</li>
<li><b>Continue</b></li>
</ul>
</li>
<li><b>Blocks</b></li>
<li style="list-style-type: none"><ul><li><b>Syntax</b></li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">Only support named blocks:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none"><tt>+block</tt>&nbsp;<i>identifier</i></li>
<li style="list-style-type: none"><ul><li style="list-style-type: none"><i>statement-sequence</i></li>
</ul>
</li>
<li style="list-style-type: none"><tt>−block</tt>&nbsp;<i>identifier</i></li>
</ul>
</li>
<li style="list-style-type: none">Or both named and nameless versions:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none"><tt>+block</tt></li>
<li style="list-style-type: none"><ul><li style="list-style-type: none"><i>statement-sequence</i></li>
</ul>
</li>
<li style="list-style-type: none"><tt>−block</tt></li>
<li style="list-style-type: none"></li>
<li style="list-style-type: none"><tt>+block:</tt>&nbsp;<i>identifier</i></li>
<li style="list-style-type: none"><ul><li style="list-style-type: none"><i>statement-sequence</i></li>
</ul>
</li>
<li style="list-style-type: none"><tt>−block:</tt>&nbsp;<i>identifier</i></li>
</ul>
</li>
</ul>
</li>
<li><b>Paired Calls</b></li>
<li style="list-style-type: none"><ul><li>Could also be called "bracketing calls" or "slotted blocks" or "slot-bearing blocks".</li>
<li>The idea is to have a special block statement that will include two "slots": one at its opening 'tag' and one at its closing one. Those 'slots' will host function calls that will be executed whenever control flow reaches each slot. The compiler will check that the functions mentioned are declared as a 'pair' and that the call at the opening slot is the first pair member while the call at the closing slot is the second pair member. The function at the exit slot will be executed regardless of the way in which control flow exited the scope of the block (exception, return, fall-off, etc.).</li>
<li>The goal is to give the programmer both a syntactic hint that he forgot something and proper semantic checks that he matched the calls correctly.</li>
<li style="list-style-type: none"><ul><li><b>Use Cases</b>:</li>
<li style="list-style-type: none"><ul><li>glBegin ⟷ glEnd</li>
<li>open ⟷ close</li>
<li>new ⟷ delete</li>
</ul>
</li>
</ul>
</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>How does this structure compare with D's <b>scope</b>&nbsp;statement or other statements like <b>synchronized</b>?</li>
</ul>
</li>
</ul>
</li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Blocks could be used in place of C++ namespaces and ML local-in-end structures. To that end, I could generalize the export statement to make names visible from outside when needed.</li>
<li>Perhaps I can view blocks as lists (or sets, or maps, but they need to be ordered) that contain the entities they lexically enclose.</li>
<li>Support a special type of blocks (e.g. <tt>+iblock</tt>, <tt>−iblock</tt>) that don't allow "falling off" their end.</li>
<li style="list-style-type: none"><ul><li><b>Use cases</b></li>
<li style="list-style-type: none"><ul><li>These can be useful in implementing finite automata by hand.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><b>Synchronized</b></li>
<li style="list-style-type: none"><ul><li>Should it be supported?</li>
</ul>
</li>
<li><b>With</b></li>
<li style="list-style-type: none"><ul><li><tt>+with(...), −</tt>with</li>
<li>Am I interested in <b>with</b>&nbsp;statement that 'opens' a struct/record like the one in Pascal that got copied by D?</li>
<li>Is <b>with</b>&nbsp;statement implementable from compile-time for and alias declarations?</li>
</ul>
</li>
<li><b>Scope</b></li>
<li style="list-style-type: none"><ul><li>D's <tt>scope(exit)</tt>&nbsp;should be easily implementable by using a predefined class (with a destructor) and lambda functions.</li>
<li>But what about <tt>scope(success)</tt>&nbsp;and <tt>scope(failure)</tt>?</li>
</ul>
</li>
<li><b>Assert </b>(and <b>static assert</b>)</li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Should Perl-like statement modifiers be supported?</li>
<li>Use 'pass' statements instead of empty statement (';') like in Python? (Can also be named 'skip')</li>
</ul>
</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Do I want something similar to Python's yield stamement?</li>
</ul>
</li>
</ul>
</body></html>