<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Toolchain</title>
</head><body><ul><li><b>Compiler</b></li>
<li style="list-style-type: none"><ul><li>Allow calling the compiler implicitly by using the #! notation in the first source line.</li>
<li><b>Command-line options</b></li>
<li style="list-style-type: none"><ul><li>To add instrumentation that enables logging of entry/exit input/output of any method</li>
<li>To change the maximum number of loop iterations / function recursive calls for code executed at compile-time.</li>
<li>To enable/disable the following checks, independent of debug/release mode. These are mandatory for compile-time evaluation, can only be disabled for run-time evaluation and are enabled by default in debug mode):</li>
<li style="list-style-type: none"><ul><li>array size mismatch</li>
<li>index out of bounds</li>
<li>read from uninitialized variable</li>
<li>dangling pointer use</li>
</ul>
</li>
<li>--main to add a do-nothing main function</li>
<li>-unittest to run unittests</li>
<li>-benchmark to run benchmarks</li>
<li>To choose between debug and release modes (e.g. -debug, -release). But what if you have more modes? The program will have access to this information by looking at a "mode" variable in a special namespace.</li>
<li>To define some arbitrary symbol (variable?) when calling the compiler that can be looked for by code (similar to C/C++'s #define mechanism and gcc's -D option).</li>
<li style="list-style-type: none">Those symbols will be arbitrary in number, will use 'auto' or similar for type (so that their type will be inferred from the value they get) and will all be defined in a special namespace (e.g. External).</li>
</ul>
</li>
<li><b>Optimizations</b></li>
<li style="list-style-type: none"><ul><li>Must detect pure function calls whose return value is never used and remove them, maintaining the order of evaluation of its arguments. e.g. (p++,q++);</li>
</ul>
</li>
<li><b>Diagnostics</b></li>
<li style="list-style-type: none"><ul><li><b>Errors</b></li>
<li style="list-style-type: none"><ul><li>Support supplementing <i>undefined symbol</i>&nbsp;errors with suggestions of look-alike Unicode characters. e.g. "Undefined reference to '→'. Did you mean '⟶'? (Since those can look alike in some fonts!)</li>
</ul>
</li>
<li><b>Warnings</b></li>
<li style="list-style-type: none"><ul><li>Support <i>expressive diagnostics</i>. (based on clang++ output)</li>
<li>Include an independently enabled class of "performance" warnings. e.g. one could be issued when the activation record of a function is allocated on the heap.</li>
</ul>
</li>
</ul>
</li>
<li><b>Multi-file compilations</b></li>
<li style="list-style-type: none"><ul><li>Topologically sort the module inclusion graph and compare timestamps?</li>
</ul>
</li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Provide option to keep maximum loop iteration / recursive call checks during run-time?</li>
<li>Produce LLVM byte-code in first implementation?</li>
</ul>
</li>
</ul>
</li>
<li><b>Linker</b></li>
<li><b>Documentation Tool</b></li>
<li><b>Benchmarking Tool</b></li>
<li style="list-style-type: none"><ul><li>Support grouping benchmarked functions by implemented interface and plotting results in the same graph.</li>
</ul>
</li>
<li><b>Editor</b>&nbsp;(not included)</li>
<li style="list-style-type: none"><ul><li><b>substitutions</b>&nbsp;(e.g. foreach becomes ∀).</li>
<li style="list-style-type: none"><ul><li>The editor could analyse code as you type to e.g. substitute <tt>−</tt>&nbsp;for - in "a-b", but not in "letter-like". This might need semantic analysis, besides parsing and scanning.</li>
<li>It could also perform more complex substitutions like "**2" to "²".</li>
</ul>
</li>
<li><b>typeset contexts</b></li>
<li style="list-style-type: none"><ul><li>The editor could have rules to present certain lexical and syntactic structures, like mathematical formulas, in a typeset way instead of using a fixed width font everywhere.</li>
<li>If I indeed distinguish between the language that is saved in the file and the language that is presented in the editor, then all function calls could be saved in a uniform way in the file (e.g. function-name(argument-list)) and presented to the programmer differently (e.g like an operator or a method) depending on what has been defined for each function.</li>
<li style="list-style-type: none">If someone wants to write expressions in a plain text editor, it shouldn't be harder than programming in Lisp!</li>
<li>A simple source code representation in a (UTF-8) text file could be token =&gt; type"value". Where tokens are separated by spaces or, maybe, not at all.</li>
<li style="list-style-type: none">&#09;k"keyword-name"</li>
<li style="list-style-type: none">&#09;i"identifier-name" (operators could be encoded as identifiers too)</li>
<li style="list-style-type: none">&#09;c"comment-text"</li>
<li style="list-style-type: none">&#09;s"string-text" (could include multiple prefixes depending on whether the string is ASCII, Unicode, etc.)</li>
<li style="list-style-type: none">&#09;l"single-character-name" (l for letter, or sc for single character, or something else)</li>
<li style="list-style-type: none">&#09;r"regular-expression-literal" ?</li>
<li style="list-style-type: none">&#09;numbers?</li>
<li style="list-style-type: none">All of the above can use escape sequences, but some may have additional constraints. e.g. it could be illegal for identifiers to contain line separators and keywords could be drawn from a predefined set.</li>
<li>Support comments that will 'point' to certain line or character ranges or positions in the code with arrows and braces like in the report that I've written for the Numerical Analysis course.</li>
<li style="list-style-type: none">Those could be represented in the file e.g. with 'invisible' anchors. e.g. I put an anchor in the beginning of the blcok and one at the end and in the comment I write that it refers to the code between those anchors.</li>
<li>Support actual subscripting (aᵢ).</li>
<li style="list-style-type: none"><ul><li>Syntax in the file could be: <i>identifier</i>&nbsp;<tt>subscript</tt>&nbsp;<i>expression</i>&nbsp;<tt>end</tt>.</li>
</ul>
</li>
<li>Support statements of the form: sum = ∑ᵢ₌₁ⁿaᵢ; (can't typeset properly in KeepNote...)</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>How will the whitespace in the file, map to the whitespace presented in the editor and vice versa?</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</body></html>