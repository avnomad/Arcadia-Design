<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Toolchain</title>
</head><body><ul><li><b>Compiler</b></li>
<li style="list-style-type: none"><ul><li>Allow calling the compiler implicitly by using the #! notation in the first source line.</li>
<li><b>Command-line options</b></li>
<li style="list-style-type: none"><ul><li>To add instrumentation that enables logging of entry/exit input/output of any method</li>
<li>To change the maximum number of loop iterations / function recursive calls for code executed at compile-time.</li>
<li>To enable/disable the following checks, independent of debug/release mode. These are mandatory for compile-time evaluation, can only be disabled for run-time evaluation and are enabled by default in debug mode):</li>
<li style="list-style-type: none"><ul><li>array size mismatch</li>
<li>index out of bounds</li>
<li>read from uninitialized variable</li>
<li>dangling pointer use</li>
</ul>
</li>
<li>--main to add a do-nothing main function</li>
<li>-unittest to run unittests</li>
<li>-benchmark to run benchmarks</li>
<li>To choose between debug and release modes (e.g. -debug, -release). But what if you have more modes?</li>
<li>To define some arbitrary symbol that can be searched for in code. (similar to C's #define mechanism)</li>
</ul>
</li>
<li><b>Optimizations</b></li>
<li style="list-style-type: none"><ul><li>Must detect pure function calls whose return value is never used and remove them, maintaining the order of evaluation of its arguments. e.g. (p++,q++);</li>
</ul>
</li>
<li><b>Diagnostics</b></li>
<li style="list-style-type: none"><ul><li><b>Errors</b></li>
<li style="list-style-type: none"><ul><li>Support supplementing <i>undefined symbol</i>&nbsp;errors with suggestions of look-alike Unicode characters. e.g. "Undefined reference to '→'. Did you mean '⟶'? (Since those can look alike in some fonts!)</li>
</ul>
</li>
<li><b>Warnings</b></li>
<li>Support <i>expressive diagnostics</i>. (based on clang++ output)</li>
</ul>
</li>
<li><b>Multi-file compilations</b></li>
<li style="list-style-type: none"><ul><li>Topologically sort the module inclusion graph and compare timestamps?</li>
</ul>
</li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>Provide option to keep maximum loop iteration / recursive call checks during run-time?</li>
<li>Produce LLVM byte-code in first implementation?</li>
</ul>
</li>
</ul>
</li>
<li><b>Linker</b></li>
<li><b>Documentation Tool</b></li>
<li><b>Benchmarking Tool</b></li>
<li style="list-style-type: none"><ul><li>Support grouping benchmarked functions by implemented interface and plotting results in the same graph.</li>
</ul>
</li>
<li><b>Editor</b>&nbsp;(not included)</li>
<li style="list-style-type: none"><ul><li>substitutions (e.g. foreach becomes ∀).</li>
<li style="list-style-type: none"><ul><li>The editor could analyse code as you type to e.g. substitute <tt>−</tt>&nbsp;for - in "a-b", but not in "letter-like". This might need semantic analysis, besides parsing and scanning.</li>
</ul>
</li>
<li>typeset contexts.</li>
<li style="list-style-type: none"><ul><li>The editor could have rules to present certain lexical and syntactic structures, like mathematical formulas, in a typeset way instead of using a fixed width font everywhere.</li>
</ul>
</li>
</ul>
</li>
</ul>
</body></html>