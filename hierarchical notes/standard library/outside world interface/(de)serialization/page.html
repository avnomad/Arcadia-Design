<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>(De)Serialization</title>
</head><body><ul><li><b>Standard Formats</b></li>
<li style="list-style-type: none"><ul><li>XML?</li>
<li style="list-style-type: none"><ul><li>validating XML processor </li>
</ul>
</li>
<li>Protobuf?</li>
<li>CSV?</li>
</ul>
</li>
<li><b>Combined Recognizer/Generator DSL</b></li>
<li style="list-style-type: none"><ul><li><b>Description</b></li>
<li style="list-style-type: none"><ul><li>I could offer a uniform facility for generating and recognizing strings using a single set of rules as part of the standard I/O system.</li>
<li style="list-style-type: none"><ul><li>Similar to Spirit.Karma when generating.</li>
<li>Similar to Spirit.Qi when recognizing. (i.e. a parser will be generated automatically from the grammar)</li>
</ul>
</li>
<li>For a new type I'll be able to specify its format and it will be automatically usable for input and output.</li>
<li>I'll also be able to independently customize input and output if needed, by overriding the corresponding operator.</li>
<li>Both semantic actions and assigning to patterns should be supported.</li>
<li style="list-style-type: none"><ul><li>An iteration index could be supplied to the pattern or semantic action in addition to the matched string.</li>
<li>When nesting repeat expressions there could be an option to reset the a lower-level index when a higher-level index changes.</li>
</ul>
</li>
<li>Parts of the grammar might involve optional and/or repeated sub-expressions that are not tied to any program variable. (e.g. ws*)</li>
<li style="list-style-type: none"><ul><li>They'll behave as expected when parsing (i.e. they'll be used for matching but not input any actual data)</li>
<li>When printing they can be ignored or used to fill field widths. In the latter case, an algorithm similar to that of a layout manager could decide how many instances of each such sub-expression to generate.</li>
</ul>
</li>
<li>Optional parts (.?) tied to a pointer variable could be output iff they are non-null.</li>
<li>Stream insertion and extraction operators can be generated by just declaring the rhs of the corresponding production. (e.g. if both can't be described by a single rule, but at least one of them can)</li>
<li>The is no need to specify full rules and grammars: recursion will be possible iff the type is recursive. </li>
<li>Conversion to string can be generated from stream insertion operator.</li>
<li><b>Syntax</b></li>
<li style="list-style-type: none"><ul><li>The syntax of the respective DSL (e.g. choice of operator symbols) can be based on that of another that is used for a similar purpose:</li>
<li style="list-style-type: none"><ul><li>EBNF</li>
<li>PEG</li>
<li>Regular Expressions</li>
</ul>
</li>
<li>A rule could have the form: non-terminal ~&gt; symbol sequence</li>
<li>Could use parentheses to group terms, brackets to contain and attach patterns and braces to contain and attach semantic actions.</li>
</ul>
</li>
<li><b>Interpretation</b></li>
<li style="list-style-type: none"><ul><li>Read-only values (literals, temporaries and immutable variables) will serve as terminals and need to be matched against input when reading and printed when writing.</li>
<li style="list-style-type: none"><ul><li>Although strings and characters will be input/output verbatim, exactly what characters are input/output for a given number may depend on locale and other parameters.</li>
</ul>
</li>
<li>Writable values (mutable variables) will serve as non-terminals. Their value will be read or written in recognition or generation mode respectively using the extraction or insertion operator respectively (taken from their types).</li>
<li style="list-style-type: none"><ul><li>When treating the variable's value as a terminal is desired, an explicit conversion to string could be used.</li>
</ul>
</li>
</ul>
</li>
<li><b>Remarks</b></li>
<li style="list-style-type: none"><ul><li>Semantics can differ between the string and symbol sequence concatenation operators, both represented by juxtaposition.</li>
<li>The way certain generators and recognizers work (like those for numbers) might need to depend on locale.</li>
<li style="list-style-type: none"><ul><li>These parameters could be drawn from the stream.</li>
</ul>
</li>
<li>When repeated parts input data in an array, a check will be made that the array has sufficient size or is resizable.</li>
</ul>
</li>
</ul>
</li>
<li><b>Implementation</b></li>
<li style="list-style-type: none"><ul><li>May need to define Grammar and Parser objects. Grammar = (Unicode?, Non-terminals, Productions,Initial)</li>
<li>What should be the type of <i>expression</i>&nbsp;in <tt>console &gt;&gt; expression;</tt>?</li>
<li style="list-style-type: none"><ul><li>Could be (Terminal âˆª Non-terminal)* or RuleRHS that is implicitly converted to Grammar.</li>
</ul>
</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Do semantic actions need to roll back when backtracking? How does Spirit solve this?</li>
</ul>
</li>
</ul>
</li>
<li><b>Examples</b></li>
<li style="list-style-type: none"><ul><li><tt>console &lt;&lt; elements[$0] (", " elements[$0])*</tt>&nbsp;(should print the 'elements' array, but how will the system know that the second instance of $0 should continue from where the first left off?</li>
<li><tt>console &lt;&lt; elements[$0] % ", "</tt>&nbsp;(same as above, but avoiding the issue)</li>
<li><tt>console &gt;&gt; numbers[$0] % ", ";</tt></li>
<tt><li style="list-style-type: none">sort(numbers);</li>
</tt><li style="list-style-type: none"><tt>console &lt;&lt; numbers[$0] % ", "; </tt>(reads a comma-separated list of Arcadia numbers and writes them again sorted)</li>
<li style="list-style-type: none"><tt>console &gt;&gt; (('+'|'-')? [0-9]*)[numbers[$0]] % ", ";</tt>&nbsp;(Same but only decimal numbers are accepted. It assumes an implicit conversion from string to integer is available. But how would one specify that '-' is only to be printed for negative numbers?)</li>
</ul>
</li>
<li><b>Ideas</b></li>
<li style="list-style-type: none"><ul><li>What if I could write a format:</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">sum(left,right) ::= '(' left " + " right ')'</li>
<li style="list-style-type: none">prod(left,right) ::= '(' left "*" right ')'</li>
<li style="list-style-type: none">var(name) ::= name</li>
</ul>
</li>
<li style="list-style-type: none">or even better</li>
<li style="list-style-type: none"><ul><li style="list-style-type: none">node(op,left,right) ::= '(' left op right ')'</li>
<li style="list-style-type: none">var(name) ::= name</li>
</ul>
</li>
<li style="list-style-type: none">and that format be usable for both parsing and printing expression trees?</li>
<li style="list-style-type: none">sum, prod, var, node would be the deconstructors of respective types, and those types would be assumed as the non-terminals of a grammar. The types of left and right would be used as the non-terminals of the right hand side of the rules. A declaration of the grammar (terminals, non-terminals, rules, starting non-terminal) may be needed.</li>
</ul>
</li>
<li><b>Relationship with Arcadia's parser</b></li>
<li style="list-style-type: none"><ul><li>The parser and the way of specifying the syntax could be associated with the way of specifying the syntax of Arcadia itself or not.</li>
</ul>
</li>
<li><b>Relationship with formatted I/O</b></li>
<li style="list-style-type: none"><ul><li>For backward compatibility with the syntax for formatted input, variables of a type will be directly usable as parsers of this type (instead of int_, double_, etc.) that will read input into that variable. So <tt>in &gt;&gt; a b c</tt>&nbsp;(or <tt>input a b c</tt>) will work like C++'s <tt>cin &gt;&gt; a &gt;&gt; b &gt;&gt; c</tt>.</li>
</ul>
</li>
</ul>
</li>
</ul>
</body></html>