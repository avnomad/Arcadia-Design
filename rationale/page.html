<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Rationale</title>
</head><body><ul><li><b>Designing Concrete Syntax from Scratch</b></li>
<li style="list-style-type: none"><ul><li>The choice was made to design a fresh concrete syntax rather than reuse the syntax of one of the prominent language families (C, Pascal, etc.) to stress that this is a completely new language, set expectations and avoid surprises when the corresponding semantics don't match.</li>
<li>Opportunity to avoid some nuances:</li>
<li style="list-style-type: none"><ul><li>Difficulty in parsing &lt; and &gt; for both angle brackets and comparison.</li>
<li>Dangling else problem.</li>
<li>Accidental use of = instead of == in conditions.</li>
<li>Need to comment closing braces with // end for|if|else|...</li>
</ul>
</li>
<li>Opportunity to adapt syntax to parser capabilities.</li>
</ul>
</li>
<li>The rules for selecting an encoding where selected so that international characters can still be used in systems that don't support a BOM to preceed the #! sequence.</li>
<li>The form <tt>print "Hello World!\n";</tt> wasn't used because "print" can't be generalized (to streams).</li>
<li>By using <b>fallthrough</b> I'm not hijacking <b>break</b> and <b>continue</b>.</li>
<li>Only arithmetic and geometric progressions are recognized by the sequence operator ( , ,..., ), since there is no point in submitting the readers of the code to an IQ test.</li>
<li>The distinction between value and reference classes demands a decision up front about how the classes are going to be used (whether they will be inherited etc.) and isn't in line with the language's general principle to let you start writing something and decide about the details as you go.</li>
<li>No special adaptor that adds deallocation guarantees to containers of pointers to objects was included, since the intended behaviour can be achieved by using containers of smart pointers.</li>
<li>No preprocessor meta-programming since there won't be a preprocessor.</li>
<li>Plain text source file format was selected mostly because there weren't enough resources to design and implement a decent editor and to allow programmers to use their existing editor-of-choice.</li>
<li>One of the reasons for making Arcadia extensible was so that projects like Qt and ODB for C++ wouldn't have to write their own compiler/preprocessor but rather extend the language by writting a library.</li>
<li><b>Choice of Names</b></li>
<li style="list-style-type: none"><ul><li>Linear data structures could have a <i>length</i> member, but this name doesn't generalize to trees and graphs. They could have a <i>size</i> member, but this will be used for byte count instead.</li>
</ul>
</li>
<li><b>Choice of Symbols</b></li>
<li style="list-style-type: none"><ul><li>The ↜ and &lt;~ operators were used for assignment, even though they are harder to write than =, because they don't match any mathematical symbol used elsewhere.</li>
<li>The <b>|</b> and <b>||</b> operators weren't used for bitwise and logical disjunction respectively because the former was needed for conditional probability and the latter to test whether two lines or vectors were parallel.</li>
<li>Angle brackets weren't used for argument lists because of the ambiguities caused from using the '&lt;' and '&gt;' characters for both the former and comparison (&lt;,&gt;) and shift (&lt;&lt;,&gt;&gt;) operators. Those ambiguities affected both the compiler's speed and complexity and the complexity of defining the language in C++.</li>
</ul>
</li>
<li><b>Todo</b></li>
<li style="list-style-type: none"><ul><li>Explain the ambiguity caused by using parenthesis for both tuple creation and function application, find examples of this ambiguity in mathematical books, and mention how the problem is avoided in Python, Mathematica and Matlab.</li>
<li>e.g. f:ℝ²→ℝ f(x)=2x+y. f(3,5) = 2*3+5 or (3f,5f)</li>
</ul>
</li>
</ul>
</body></html>
